#!/bin/sh
set -e

PREREQS=""
case $1 in
    prereqs) echo "${PREREQS}"; exit 0;;
esac

. /scripts/functions

msg() { echo "GROWROOT:" "$@" ; }
fail() { [ $# -eq 0 ] || msg "$@"; exit 1; }

###
### This runs right before exec of /sbin/init. The real root is
### already mounted at rootmnt
###
TEMP_D=""
RESTORE_FROM=""

# if a file indicates we should do nothing, then just exit
for f in /var/lib/cloud/instance/root-grown /etc/growroot-disabled \
	/etc/growroot-grown; do
	[ -f "${rootmnt}$f" ] && exit 0
done

# figure out what disk ROOT is on
{ [ ! -L "${ROOT}" ] && rootdev=${ROOT} || rootdev=$(readlink -f "${ROOT}") ; } ||
	fail "failed to get target of link for ${ROOT}"

case "${rootdev}" in
	*[0-9]) : ;;
	# the root is a disk, not a partition (does not end in a digit)
	# no need to do anything in this case, kernel already knows the full size.
    *) exit 0;;
esac

# remove all consective numbers from the end of rootdev to get 'rootdisk'
rootdisk=${rootdev}
while [ "${rootdisk%[0-9]}" != "${rootdisk}" ]; do
	rootdisk=${rootdisk%[0-9]};
done
partnum=${rootdev#${rootdisk}}

# account for devnameNpP devices (like mmcblk0p1).
if [ "${rootdisk%[0-9]p}" != "${rootdisk}" ] &&
	[ -b "${rootdisk%p}" ]; then
	rootdisk="${rootdisk%p}"
fi

# if the basename of the root device (ie 'xvda1' or 'sda1') exists
# in /sys/block/ then it is a block device, not a partition
# (xen xvda1 is an example of such a funny named block device)
[ -e "/sys/block/${rootdev##*/}" ] && exit 0

# if growpart fails, exit.
# we capture stderr because on success of dry-run, it writes
# to stderr what it would do.
out=$(growpart --dry-run "${rootdisk}" "${partnum}" 2>&1)
ret=$?

# if growpart would change something, --dry-run will write something like
#  CHANGE: partition=1 start=2048 old: size=1024000 end=1026048 new: size=2089192,end=2091240
# newer versions of growpart will exit
#   0: with 'CHANGE:*' in output on changed
#   1: with 'NOCHANGE:*' in output on no-change-necessary
#   2: error occurred
# older versions of growpart would exit '1' on all failure scenarios
# or with 'no-change-necessary'
case "$ret:$out" in
	0:CHANGE:*) :;;
	[01]:NOCHANGE:*) exit 0;;
	*) msg "exited '$ret'" "${out}"; exit 1;;
esac

# There was something to do, unmount and resize
umount "${rootmnt}" ||
	fail "failed to umount ${rootmnt}";

# Wait for any of the initial udev events to finish
# This is to avoid any other processes using the block device that the
# root partition is on, which would cause the sfdisk 'BLKRRPART' to fail.
udevadm settle --timeout ${ROOTDELAY:-30} ||
	error "GROWROOT: WARNING: udevadm settle prior to growpart failed"

if out=$(growpart "${rootdisk}" "${partnum}" 2>&1); then
	case "$out" in
		CHANGED:*) echo "GROWROOT: $out";;
    	NOCHANGE:*)
			echo "GROWROOT: WARNING: expected to grow partition, but did not";;
		*) echo "GROWROOT: unexpected output: ${out}"
	esac
else
	echo "GROWROOT: WARNING: resize failed: $out"
fi

# Wait for the partition re-read events to complete 
# so that the root partition is available when we try and mount it.
udevadm settle --timeout ${ROOTDELAY:-30}

# this is taken from 'mountroot' function
#   see /usr/share/initramfs-tools/scripts/local
FSTYPE=$(wait-for-root "${ROOT}" ${ROOTDELAY:-30})
roflag="-r"
[ "${readonly}" = "y" ] || roflag="-w"
mount ${roflag} ${FSTYPE:+-t ${FSTYPE} }${ROOTFLAGS} ${ROOT} ${rootmnt} ||
	fail "failed to re-mount ${ROOT}. this is bad!"

# write to /etc/grownroot-grown. most likely this wont work (readonly)
{ date --utc > "${rootmnt}/etc/growroot-grown" ; } >/dev/null 2>&1 || :

# vi: ts=4 noexpandtab
